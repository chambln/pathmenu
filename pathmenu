#!/bin/sh
# pathmenu
# Copyright (c) 2020 Gregory L. Chamberlain
# Available under the MIT License -- see LICENSE file.

NEWLINE='
'

browse ()
{
    for match in $patterns; do
        # Skip unexpanded patterns.
        [ -e "$match" ] || continue

        # Append a forward slash to directories if required.
        $append_slashes && [ -d "$match" ] && match=${match%/}/

        case $match in
            # Skip file names that contain a new line character, because
            # we are using the new line character as a delimiter for piping
            # file names into dmenu(1).
            *"$NEWLINE"*) continue ;;

            # Protect certain matches from cd(1) options parsing by
            # keeping their ‘./’ prefixes.  POSIX specifies -L and
            # -P, but implementations may provide additional options,
            # so we protect all file names that begin with a hyphen just
            # to be extra safe.
            ./-*) printf '%s\n' "$match" ;;

            # For other matches, ‘$match’ and ‘./$match’ are
            # almost certainly equivalent, so we can safely remove the
            # ‘./’ prefix for the sake of readability.
            #
            # The only exception I’m aware of is when ‘$match/’ exists
            # in a CDPATH directory that is positioned _in front of_
            # ‘.’, in which case perhaps the user intends to go
            # there -- especially since their CDPATH is configured that
            # way. See cd(1).
            #
            # My understanding is this:  With CDPATH unset or empty,
            # or ‘CDPATH=.’, or ‘CDPATH=.:*’ where * is anything, then
            # ‘$match’ necessarily means ‘./$match’.
            *) printf '%s\n' "${match#./}"
        esac
    done | eval "$dmenu" | while IFS= read -r target
    do
        # Strip ‘file://’ prefix -- useful for pasting in URIs.
        [ "${target##file://*}" ] && target=${target#file://}

        # ‘${target:=~/}’: Empty selection refers to the home
        #                  directory, analogous to ‘cd’ with no
        #                  argument -- see cd(1).
        # shellcheck disable=SC2086
        case ${target:=~/} in
            -)   ( cd $cd_opt - >/dev/null 2>&1 && browse "$@" ) ;;
            .)   printf '%s\n' "${PWD%/}" ;;
            ./)  printf '%s\n' "${PWD%/}"/ ;;
            ..)  printf '%s\n' "${PWD%/?*}" ;;
            */)  ( if [ -d "$target" ] && cd $cd_opt "$target" >/dev/null 2>&1
                   then browse "$@"
                   else printf '%s\n' "${PWD%/}/${target#./}"
                   fi ) ;;
            *)   printf '%s\n' "${PWD%/}/${target#./}"
        esac
    done
}

A=- a=- d=-
append_slashes=false

# shellcheck disable=SC2016
dmenu='dmenu -p "$PWD"/'

while :; do
    case $1 in
        -A) A=A ;;
        -F) append_slashes=true ;;
        -P) cd_opt=$1 ;;
        -a) a=a ;;
        -c) dmenu=$2; shift ;;
        -d) d=d ;;
        --) shift; break ;;
        -*) printf 'No such option: %s\n' "$1" >&2; exit 2 ;;
        *) break ;;
    esac
    shift
done

case $A$a$d in
    ---) patterns='./*' ;;
    A--) patterns='./.[^.]* ./..?* ./*' ;;
    -a-) patterns='./.* ./*' ;;
    Aa-) patterns='./. ./.. ./*' ;;
    --d) patterns='./*/' ;;
    A-d) patterns='./.[^.]*/ ./..?*/ ./*/' ;;
    -ad) patterns='./. ./.. ./.[^.]*/ ./*/' ;;
    Aad) patterns='./. ./.. ./*/' ;;
esac

browse
