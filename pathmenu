#!/bin/sh

newline='
'

browse ()
{
    for match in $patterns
    do
        # Skip unexpanded patterns.
        [ -e "$match" ] || continue

        # Append a forward slash to directories.
        [ -d "$match" ] && match=$match/

        case $match in
            # Skip file names that contain a new line character.
            *"$newline"*) continue ;;

            # Protect ‘$match/’ from cd(1) options parsing by keeping
            # the ‘./’ prefix.
            ./-*/) printf '%s\n' "$match" ;;

            # For other matches, ‘$match’ and ‘./$match’ are
            # almost certainly equivalent, so we can remove the ‘./’
            # prefix for the sake of readability.
            #
            # The only exception I’m aware of is when ‘$match/’ exists
            # in a CDPATH directory that is positioned _in front of_
            # ‘.’, in which case perhaps the user intends to go
            # there -- especially since their CDPATH is configured that
            # way. See cd(1).
            #
            # My understanding is this:  With CDPATH unset or empty,
            # or ‘CDPATH=.’, or ‘CDPATH=.:*’ where * is anything, then
            # ‘$match’ can only refer to ‘./$match’.
            *) printf '%s\n' "${match#./}"
        esac
    done | dmenu -p "$PWD" "$@" | while IFS= read -r target
    do
        case $target in
            */)
                # Recursive case: Descend into $target and browse.
                ( cd -P "$target" >/dev/null 2>&1 && browse "$@" )
                ;;
            *)
                # Base case.
                printf '%s\n' "$PWD/${target#./}"
        esac
    done
}

patterns='./.* ./*'

browse "$@"
