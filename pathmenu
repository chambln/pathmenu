#!/bin/sh
# pathmenu
# Copyright (c) 2020 Gregory L. Chamberlain
# Available under the MIT License -- see LICENSE file.

newline='
'

browse ()
{
    for match in $patterns
    do
        # Skip unexpanded patterns.
        [ -e "$match" ] || continue

        # Append a forward slash to directories.
        [ -d "$match" ] && match=$match/

        case $match in
            # Skip file names that contain a new line character, because
            # we are using the new line character as a delimiter for piping
            # file names into dmenu(1).
            *"$newline"*) continue ;;

            # Protect certain matches from cd(1) options parsing by
            # keeping their ‘./’ prefixes.  POSIX specifies -L and
            # -P, but implementations may provide additional options,
            # so we protect all file names that begin with a hyphen just
            # to be extra safe.
            ./-*) printf '%s\n' "$match" ;;

            # For other matches, ‘$match’ and ‘./$match’ are
            # almost certainly equivalent, so we can safely remove the
            # ‘./’ prefix for the sake of readability.
            #
            # The only exception I’m aware of is when ‘$match/’ exists
            # in a CDPATH directory that is positioned _in front of_
            # ‘.’, in which case perhaps the user intends to go
            # there -- especially since their CDPATH is configured that
            # way. See cd(1).
            #
            # My understanding is this:  With CDPATH unset or empty,
            # or ‘CDPATH=.’, or ‘CDPATH=.:*’ where * is anything, then
            # ‘$match’ necessarily means ‘./$match’.
            *) printf '%s\n' "${match#./}"
        esac
    done | dmenu -p "$PWD" "$@" | while IFS= read -r target
    do
        # Strip URI prefix ‘file://’.
        [ "${target##file://*}" ] && target=${target#file://}

        # ‘${target:-~/}’: Empty selection refers to the home
        #                  directory, analogous to ‘cd’ with no
        #                  argument -- see cd(1).
        case ${target:=~/} in
            -)   ( cd - >/dev/null 2>&1 && browse "$@" ) ;;
            .)   printf '%s\n' "${PWD%/}" ;;
            ./)  printf '%s\n' "${PWD%/}"/ ;;
            ..)  printf '%s\n' "${PWD%/?*}" ;;
            */)  ( cd -P "$target" >/dev/null 2>&1 && browse "$@" ) ||
                   printf '%s\n' "${PWD%/}/${target#./}"  ;;
            *)   printf '%s\n' "${PWD%/}/${target#./}"
        esac
    done
}

patterns='./.* ./*'

browse "$@"
